package tu.paquete;

import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDate;
import java.text.Normalizer;
import java.util.List;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathConstants;

import io.cucumber.java.en.When;

public class OperationsFormsBaca extends BaseCommonStepDefs {

    // Guarda la última ruta generada para usarla en otros steps
    private static Path ULTIMO_XML_GENERADO;

    // ========== STEP 1: Generar el XML desde la plantilla ==========
    @When("^Agentsit\\s+Actualizo\\s+XML\\s+\"([^\"]+)\"\\s+con\\s+nombre\\s+de\\s+(\\$\\w+)$")
    public void actualizoXmlGenerandoNuevo(String rutaXml, String nombreParam) throws Exception {
        System.out.println("==[XML Update]==");
        System.out.println("Plantilla (no se sobreescribe): " + rutaXml);

        // 0) Asegurar plantilla
        Path plantillaPath = Paths.get(rutaXml);
        if (!Files.exists(plantillaPath)) {
            Path bak = Paths.get(rutaXml + ".bak");
            if (Files.exists(bak)) {
                Files.copy(bak, plantillaPath, StandardCopyOption.REPLACE_EXISTING);
                System.out.println("Plantilla restaurada desde .bak");
            } else {
                throw new java.io.FileNotFoundException("No existe la plantilla: " + plantillaPath.toAbsolutePath());
            }
        }

        // 1) Cargar TXT con números
        Path txtPath = Paths.get("numeros_formularios_masivos.txt");
        List<String> numeros = Files.readAllLines(txtPath, StandardCharsets.UTF_8);
        numeros.removeIf(s -> s == null || s.trim().isEmpty());
        if (numeros.isEmpty())
            throw new IllegalStateException("El TXT está vacío: " + txtPath.toAbsolutePath());

        // 2) Cargar XML (plantilla)
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setNamespaceAware(true);
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document doc = db.parse(plantillaPath.toFile());
        doc.getDocumentElement().normalize();

        // 3) XPaths
        XPath xp = XPathFactory.newInstance().newXPath();
        String XP_NUM  = "//*[local-name()='numeroDeclaracion' or local-name()='referenceNumber']";
        String XP_FECH = "//*[local-name()='fechaDeclaracion' or local-name()='declarationDate']";
        NodeList nn = (NodeList) xp.evaluate(XP_NUM,  doc, XPathConstants.NODESET);
        NodeList nf = (NodeList) xp.evaluate(XP_FECH, doc, XPathConstants.NODESET);
        if (nn.getLength() == 0 || nf.getLength() == 0)
            throw new IllegalStateException("No se encontraron nodos de número o fecha en el XML.");

        // Usar solo lo disponible
        int n = Math.min(Math.min(nn.getLength(), nf.getLength()), numeros.size());
        if (n == 0)
            throw new IllegalStateException("No hay nada para procesar: numero=" + nn.getLength()
                    + ", fecha=" + nf.getLength() + ", TXT=" + numeros.size());

        String hoy = LocalDate.now().toString();
        for (int i = 0; i < n; i++) {
            nn.item(i).setTextContent(numeros.get(i));
            nf.item(i).setTextContent(hoy);
        }

        // 4) Resolver nombre base desde tu contexto
        String nombreBase = resolverNombreBaseDesdeContexto(nombreParam);
        if (nombreBase == null || nombreBase.isBlank())
            throw new IllegalStateException("No pude resolver el nombre capturado. Ejecuta antes el step 'read text ... into "
                    + nombreParam + "'.");

        // 4.b) Construir nombre especial: baseSinExt + "_0001" + "_" + ultimaParte + ".xml"
        String base = nombreBase.trim();
        String baseSinExt = base.replaceFirst("(?i)\\.xml$", "");
        String ultimaParte = baseSinExt.contains("_")
                ? baseSinExt.substring(baseSinExt.lastIndexOf('_') + 1)
                : baseSinExt;

        baseSinExt = Normalizer.normalize(baseSinExt, Normalizer.Form.NFD)
                .replaceAll("\\p{M}+", "")
                .replaceAll("[^A-Za-z0-9._-]", "_")
                .replaceFirst("^_+", "");
        ultimaParte = Normalizer.normalize(ultimaParte, Normalizer.Form.NFD)
                .replaceAll("\\p{M}+", "")
                .replaceAll("[^A-Za-z0-9._-]", "_")
                .replaceFirst("^_+", "");

        Path dir = (plantillaPath.getParent() == null) ? Paths.get(".") : plantillaPath.getParent();
        String nombreFinal = baseSinExt + "_0001" + (ultimaParte.isEmpty() ? "" : "_" + ultimaParte) + ".xml";
        Path destino = dir.resolve(nombreFinal); // siempre REPLACE_EXISTING

        System.out.println("Archivo final (se sobrescribe si ya existe): " + destino.toAbsolutePath());

        // 5) Guardar el XML modificado
        Transformer tf = TransformerFactory.newInstance().newTransformer();
        tf.setOutputProperty(OutputKeys.INDENT, "yes");
        tf.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
        tf.transform(new DOMSource(doc), new StreamResult(destino.toFile()));

        // (Opcional) actualizar .bak de la plantilla
        try {
            Files.copy(plantillaPath, Paths.get(rutaXml + ".bak"), StandardCopyOption.REPLACE_EXISTING);
        } catch (Exception ex) {
            System.out.println("No se pudo crear backup de la plantilla (continuo): " + ex.getMessage());
        }

        // >>> Guarda la ruta del último XML generado <<<
        ULTIMO_XML_GENERADO = destino;

        // También dejo la ruta en el portapapeles
        try {
            StringSelection sel = new StringSelection(destino.toAbsolutePath().toString());
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(sel, null);
        } catch (Throwable ignore) { }

        System.out.println("Plantilla intacta: " + plantillaPath.toAbsolutePath());
        System.out.println("Nuevo XML generado: " + destino.toAbsolutePath());
        System.out.println("Fecha aplicada: " + hoy + " | Nodos actualizados: " + n);
    }

    // ========== STEP 2: Copiar el último XML a carpeta “portátil” ==========
    @When("^Agentsit\\s+creo\\s+copia\\s+del\\s+archivo\\s+en\\s+la\\s+ruta\\s+\"([^\"]+)\"$")
    public void copiaXML(String rutaDestinoHint) throws Exception {
        if (ULTIMO_XML_GENERADO == null || !Files.exists(ULTIMO_XML_GENERADO)) {
            throw new IllegalStateException("No hay un XML generado recientemente para copiar.");
        }
        Path origen = ULTIMO_XML_GENERADO;

        Path dirDestino = resolverDirectorioPortatil(rutaDestinoHint);
        Files.createDirectories(dirDestino);

        Path destino = dirDestino.resolve(origen.getFileName());
        Files.copy(origen, destino, StandardCopyOption.REPLACE_EXISTING);

        // Dejo también la ruta de la copia en el portapapeles
        try {
            StringSelection sel = new StringSelection(destino.toAbsolutePath().toString());
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(sel, null);
        } catch (Throwable ignore) { }

        System.out.println("Copia creada en: " + destino.toAbsolutePath());
    }

    // ========== Helper: Resolver nombre desde contexto ==========
    private String resolverNombreBaseDesdeContexto(String nombreParam) {
        try {
            Object last = this.getScenarioContext().getLastStepResultVariable();
            if (last != null) {
                if (last.getClass().isArray()) {
                    int len = java.lang.reflect.Array.getLength(last);
                    if (len > 0) {
                        Object first = java.lang.reflect.Array.get(last, 0);
                        return first != null ? String.valueOf(first) : null;
                    }
                } else {
                    return String.valueOf(last);
                }
            }
        } catch (Throwable ignore) { }

        try {
            String key = (nombreParam != null && nombreParam.startsWith("$"))
                    ? nombreParam.substring(1) : nombreParam;
            Object gcVal = GlobalContext.get(key);
            if (gcVal == null) gcVal = GlobalContext.get(nombreParam);
            return (gcVal != null) ? String.valueOf(gcVal) : null;
        } catch (Throwable ignore) { }

        return null;
    }

    // ========== Helper: Resolver carpeta “portátil” ==========
    private Path resolverDirectorioPortatil(String hint) {
        if (hint == null || hint.isBlank()) {
            hint = "Downloads"; // default
        }
        String h = hint.trim();
        Path p = Paths.get(h);
        if (p.isAbsolute()) return p;

        String low = h.toLowerCase();
        Path home = Paths.get(System.getProperty("user.home"));

        if (low.contains("download")) return home.resolve("Downloads");
        if (low.contains("desktop"))  return home.resolve("Desktop");
        if (low.contains("document")) return home.resolve("Documents");

        if (Files.exists(home.resolve(h))) return home.resolve(h);

        return Paths.get(h).toAbsolutePath();
    }
}
