@When("^Extraigo datos del ultimo XML en la ruta \"([^\"]+)\" con prefijo \"([^\"]*)\"$")
public void extraigoDatosDelUltimoXML(String carpetaXML, String prefijo) throws Exception {
    // 1) Carpeta
    Path dir = Paths.get(System.getProperty("user.dir"), carpetaXML);
    if (!Files.isDirectory(dir)) {
        throw new Exception("[XML] Carpeta no válida: " + dir.toAbsolutePath());
    }

    // 2) Elegir el XML más reciente (filtrando por prefijo si viene)
    Path ultimoXml;
    try (var s = Files.list(dir)) {
        ultimoXml = s.filter(p -> p.toString().toLowerCase(Locale.ROOT).endsWith(".xml"))
                     .filter(p -> prefijo == null || prefijo.isBlank()
                                  || p.getFileName().toString().startsWith(prefijo))
                     .max(Comparator.comparingLong(p -> p.toFile().lastModified()))
                     .orElseThrow(() -> new Exception("[XML] No hay XML en " + dir.toAbsolutePath() +
                                                      (prefijo == null ? "" : " con prefijo '" + prefijo + "'")));
    }
    System.out.println("[XML] Archivo más reciente: " + ultimoXml.getFileName() +
            " (mtime=" + Files.getLastModifiedTime(ultimoXml) + ")");

    // 3) Parsear XML
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    dbf.setNamespaceAware(false);
    dbf.setExpandEntityReferences(false);
    Document doc = dbf.newDocumentBuilder().parse(ultimoXml.toFile());
    doc.getDocumentElement().normalize();

    // 4) Aplanar TODO el árbol (elementos y atributos)
    Map<String, String> flat = new LinkedHashMap<>();
    String rootName = doc.getDocumentElement().getNodeName(); // normalmente "root"
    flattenXml(doc.getDocumentElement(), rootName, flat);

    System.out.println("[XML] Total de campos aplanados: " + flat.size());
    // flat.forEach((k, v) -> System.out.println("[XML] " + k + " = " + v)); // (opcional)

    // 5) Construir SOLO claves con alias OPF_* a partir de la sección que te interesa
    //    Si tus datos están en <servicioOtro> usa esa base; puedes añadir más si lo necesitas.
    String base = rootName + ".servicioOtro."; // ejemplo: "root.servicioOtro."
    Map<String, String> out = new LinkedHashMap<>();
    for (Map.Entry<String,String> e : flat.entrySet()) {
        String k = e.getKey();
        if (k.startsWith(base)) {
            String tail = k.substring(base.length());   // p.ej. "fechaDeclaracion"
            out.put("OPF_" + tail, e.getValue());       // -> OPF_fechaDeclaracion
        }
    }

    System.out.println("[JSON] Total de claves OPF_*: " + out.size());
    out.forEach((k,v) -> System.out.println("  " + k + " = " + v));

    // 6) Guardar JSON (SOBREESCRIBE para evitar duplicados)
    Path outJson = Paths.get(System.getProperty("user.dir"), "ultimo_xml_OPF.json");
    String json = new org.json.JSONObject(out).toString(2); // requiere org.json en el classpath
    Files.writeString(
        outJson, json, StandardCharsets.UTF_8,
        StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE
    );

    System.out.println("[JSON] Guardado en: " + outJson.toAbsolutePath());
}

/* ============ Helpers sencillos ============ */

/** Recorre recursivamente el XML y llena 'out' con claves "path.tag" (también atributos "@attr"). */
private static void flattenXml(Node node, String path, Map<String, String> out) {
    // 1) Atributos del nodo como keys "path@attr"
    if (node.hasAttributes()) {
        NamedNodeMap atts = node.getAttributes();
        for (int i = 0; i < atts.getLength(); i++) {
            Node a = atts.item(i);
            String k = path + "@" + a.getNodeName();
            putNoOverwrite(out, k, a.getNodeValue());
        }
    }

    // 2) Hijos elemento
    NodeList children = node.getChildNodes();
    List<Element> elemChildren = new ArrayList<>();
    for (int i = 0; i < children.getLength(); i++) {
        Node n = children.item(i);
        if (n.getNodeType() == Node.ELEMENT_NODE) elemChildren.add((Element) n);
    }

    if (elemChildren.isEmpty()) {
        // Hoja: guardar texto si no está vacío
        String text = node.getTextContent() == null ? "" : node.getTextContent().trim();
        if (!text.isEmpty()) putNoOverwrite(out, path, text);
        return;
    }

    // Recurse
    for (Element e : elemChildren) {
        String tag = e.getNodeName().replaceAll("\\s+", "");
        flattenXml(e, path + "." + tag, out);
    }
}

/** Inserta (clave, valor). Si ya existe la clave, crea sufijo [2], [3], ... para no perder datos. */
private static void putNoOverwrite(Map<String, String> out, String key, String value) {
    if (value == null) value = "";
    value = value.trim();
    if (value.isEmpty()) return;

    if (!out.containsKey(key)) {
        out.put(key, value);
        return;
    }
    int i = 2;
    while (out.containsKey(key + "[" + i + "]")) i++;
    out.put(key + "[" + i + "]", value);
}
