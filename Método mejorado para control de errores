@When("^cargandobatosOPF \"([^\"]+)\" \"([^\"]+)\" \"([^\"]+)\"$")
public void cargandobatosOPF(String agentName, String nombreArchivo, String varName) throws Exception {

    // ===== 0) Config: fallar al final o solo reportar
    boolean failAtEnd = Boolean.parseBoolean(System.getProperty("opf.failAtEnd", "true"));
    List<String> globalErrors = new ArrayList<>();

    // ===== 1) Archivos de soporte =====
    Path rutaIds  = Paths.get(System.getProperty("user.dir"), "identificador_generadoXML.txt");        // ids 1..5, uno por línea
    Path rutaNums = Paths.get(System.getProperty("user.dir"), "numeros_formularios_generadoXML.txt");   // numeroDeclaracion, uno por línea

    if (!Files.exists(rutaIds))  throw new Exception("[OPF] Falta identificador_generadoXML.txt: " + rutaIds.toAbsolutePath());
    if (!Files.exists(rutaNums)) throw new Exception("[OPF] Falta numeros_formularios_generadoXML.txt: " + rutaNums.toAbsolutePath());

    // ids: deja solo dígitos por línea
    List<String> ids = Files.readAllLines(rutaIds, StandardCharsets.UTF_8).stream()
            .filter(s -> s != null && !s.isBlank())
            .map(s -> s.replaceAll("[^0-9]", ""))
            .filter(s -> !s.isBlank())
            .collect(Collectors.toList());
    if (ids.isEmpty()) throw new Exception("[OPF] Archivo de IDs vacío.");

    // numerosDeclaracion (solo para logging/consistencia)
    List<String> numerosDec = Files.readAllLines(rutaNums, StandardCharsets.UTF_8).stream()
            .filter(s -> s != null && !s.isBlank())
            .map(String::trim)
            .collect(Collectors.toList());

    // ===== 2) Leer JSON plano =====
    Path rutaJson = Paths.get(System.getProperty("user.dir"), nombreArchivo);
    if (!Files.exists(rutaJson)) throw new Exception("[OPF] No existe el JSON: " + rutaJson.toAbsolutePath());

    String json = Files.readString(rutaJson, StandardCharsets.UTF_8).trim();
    Map<String,String> kv = JsonUtils.parseFlatJsonToMap(json);
    System.out.println("[JSON] Campos: " + kv.size());

    // ===== 3) Iterar por bloque (posición) =====
    int bloques = Math.min(ids.size(), Math.max(
            countBlocks(kv, "OPF numeroDeclaracion_"),
            countBlocks(kv, "OPF fechaDeclaracion_")
    ));
    if (bloques == 0) throw new Exception("[OPF] No se detectaron bloques en el JSON (OPF numeroDeclaracion_n).");

    for (int i = 0; i < bloques; i++) {
        String id = ids.get(i);              // "1".."5"
        String sufijo = "_" + (i + 1);       // "_1", "_2", ...

        // ===== 3.1 Datos mínimos del bloque =====
        String numeroDeclaracion = kv.get("OPF numeroDeclaracion" + sufijo);
        String fechaDeclaracion  = kv.get("OPF fechaDeclaracion"  + sufijo);

        if (numeroDeclaracion == null || numeroDeclaracion.isBlank()) {
            String msg = "[OPF] Falta OPF numeroDeclaracion" + sufijo + " en JSON.";
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }
        if (fechaDeclaracion == null || fechaDeclaracion.isBlank()) {
            String msg = "[OPF] Falta OPF fechaDeclaracion" + sufijo + " en JSON.";
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }

        String fechaFormateada = DateUtils.toOracleDayMonYY(fechaDeclaracion);
        System.out.printf("[OPF] Bloque %s | ID=%s | numeroDeclaracion=%s | fechaBD=%s%n",
                sufijo, id, numeroDeclaracion, fechaFormateada);

        // ===== 3.2 Tabla/columnas por ID =====
        String tabla, idCol1, dateCol1;
        switch (id) {
            case "1":
                tabla   = "BAC_FSV1_FOR_IMPORT_BIENES";
                idCol1  = "DST_NUM_DECL_INIC";
                dateCol1= "DST_FECHA_DEC_INIC";
                break;
            case "2":
                tabla   = "DIB_FSV1_FOR_DECLA_EXPOR_BIEN";
                idCol1  = "DST_NUM_DECL_INIC";
                dateCol1= "DST_FECHA_DEC_INIC";
                break;
            case "3":
                tabla   = "BAC_FSV1_FOR_ENDEUDA_EXTER";
                idCol1  = "DST_NUM_DECL_INIC";
                dateCol1= "DST_FECHA_DEC_INIC";
                break;
            case "4":
                tabla   = "BAC_FSV1_FOR_INV_INTERNAREST";
                idCol1  = "DST_NUM_DECL_INIC";
                dateCol1= "DST_FECHA_DEC_INIC";
                break;
            case "5":
                tabla   = "BAC_FSV1_FOR_SERV_TRANS_OTROS";
                idCol1  = "DST_NUM_DECL_INIC";
                dateCol1= "DST_FECHA_DEC_INIC";
                break;
            default:
                String msg = "ID de formulario desconocido: " + id + " (bloque " + sufijo + ")";
                System.out.println(msg);
                globalErrors.add(msg);
                continue;
        }

        // ===== 3.3 SQL =====
        String sql = "SELECT JSON_OBJECT(*) AS ROW_JSON " +
                "FROM " + tabla + " " +
                "WHERE " + idCol1  + " LIKE '%" + numeroDeclaracion + "%' " +
                "AND "   + dateCol1+ " = '" + fechaFormateada + "' " +
                "FETCH FIRST 1 ROWS ONLY";
        System.out.println("[BD] SQL -> " + sql);

        // ===== 3.4 Ejecutar con tu agente (NO romper si falla) =====
        Agent dbAgent = AgentsManager.getOrCreateAgent(agentName);
        StepResult db;
        try {
            db = dbAgent.runWithResult("query", new Object[]{sql});
        } catch (Exception ex) {
            String msg = "[BD] Error ejecutando query (bloque " + sufijo + "): " + ex.getMessage();
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }
        if (db == null) {
            String msg = "[BD] StepResult nulo (bloque " + sufijo + ")";
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }
        getScenarioContext().saveLastStepResult(db, varName);   // por si luego lo necesitas

        String rowJson = String.valueOf(db.getFieldValue("ROW_JSON"));
        if (rowJson == null || rowJson.isBlank() || "null".equalsIgnoreCase(rowJson)) {
            rowJson = String.valueOf(db.getFieldValue("row_json")); // a veces alias minúscula
        }
        if (rowJson == null || rowJson.isBlank() || "null".equalsIgnoreCase(rowJson)) {
            String msg = "[BD] Consulta vacía (bloque " + sufijo + ")";
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }
        System.out.println("[BD] ROW_JSON (bloque " + sufijo + "): " + rowJson);

        // ===== 3.5 Bloque de JSON a validar (solo claves OPF *_<n>) =====
        Map<String,String> kvBlock = new LinkedHashMap<>();
        kv.forEach((k,v) -> {
            if (k.startsWith("OPF ") && k.endsWith(sufijo) && v != null && !v.isBlank()) {
                kvBlock.put(k, v);
            }
        });

        // Overrides por campo base (sin sufijo). Ejemplo: formatear fecha
        Map<String,String> overrides = new HashMap<>();
        overrides.put("OPF fechaDeclaracion", DateUtils.toOracleDayMonYY(fechaDeclaracion));

        // ===== 3.6 Validación (acumular OK/FAIL) =====
        String haystack = normalizeString(rowJson);
        List<String> oks   = new ArrayList<>();
        List<String> fails = new ArrayList<>();

        for (Map.Entry<String,String> e : kvBlock.entrySet()) {
            String keyWithSuffix = e.getKey();                  // "OPF campo_<n>"
            String baseKey       = keyWithSuffix.substring(0, keyWithSuffix.length() - sufijo.length());
            String value         = e.getValue();

            String candidate = overrides.getOrDefault(baseKey, value);
            if (candidate == null || candidate.isEmpty()) continue;

            String needle  = normalizeString(candidate);
            String altNeed = needle.replaceAll("[,.;:\\-/\\s]+", "");
            String altHay  = haystack.replaceAll("[,.;:\\-/\\s]+", "");

            if (haystack.contains(needle) || altHay.contains(altNeed)) {
                oks.add(baseKey + " = " + value);
            } else {
                fails.add("[BD] (Bloque " + sufijo + ") NO encontrado -> " +
                          baseKey + " = '" + value + "' (comparado='" + candidate + "')");
            }
        }

        // ===== 3.7 Resumen del bloque =====
        System.out.println(String.format("[RESUMEN] Bloque %s (ID=%s): OK=%d, FAIL=%d",
                sufijo, id, oks.size(), fails.size()));

        if (!oks.isEmpty()) {
            System.out.println("   [OK] Campos encontrados:");
            oks.forEach(s -> System.out.println("      - " + s));
        }
        if (!fails.isEmpty()) {
            System.out.println("   [FAIL] Campos faltantes:");
            fails.forEach(s -> System.out.println("      - " + s));
            globalErrors.addAll(fails);
        }

        System.out.println("[OK] Validación completada para bloque " + sufijo);
    }

    // ===== 4) Resumen final =====
    if (!globalErrors.isEmpty()) {
        System.out.println("\n===== RESUMEN FINAL: HAY FALTANTES =====");
        globalErrors.forEach(s -> System.out.println(" - " + s));
        if (failAtEnd) {
            throw new AssertionError("Existen " + globalErrors.size() + " validaciones fallidas. Revisa el log.");
        }
    } else {
        System.out.println("\n===== RESUMEN FINAL: TODO OK =====");
    }
}
