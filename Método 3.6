// === 3.6 Validación ===

// Filtra solo las entradas OPF_ del bloque actual [i]
List<Map.Entry<String, String>> kvBlock = kv.entrySet().stream()
        .filter(e -> e.getKey().startsWith("OPF_")
                && e.getKey().endsWith(sufijo)
                && e.getValue() != null
                && !e.getValue().isBlank())
        .collect(java.util.stream.Collectors.toList());

System.out.println("[JSON] busca numeroDeclaracion=" + numeroDeclaracion
        + " / fecha=" + fechaDeclaracion + " (Oracle=" + fechaFormateada + ")");

List<String> oks   = new ArrayList<>();
List<String> fails = new ArrayList<>();

// ¡OJO! kvBlock es List< Entry<...> >, se itera directo, sin entrySet()
for (Map.Entry<String, String> e : kvBlock) {
    String keyWithSuffix = e.getKey();
    String value         = e.getValue();
    String baseKey       = keyWithSuffix.substring(0, keyWithSuffix.length() - sufijo.length());

    boolean match = containsJsonValue(rowJson, value); // comparación flexible
    if (match) oks.add(baseKey);
    else       fails.add(baseKey);
}

System.out.println(String.format("[RESUMEN] Bloque %s -> OK:%d  FAIL:%d",
        sufijo, oks.size(), fails.size()));

if (!oks.isEmpty()) {
    System.out.println("[OK] Campos encontrados:");
    oks.forEach(s -> System.out.println("  ✓ " + s));
}
if (!fails.isEmpty()) {
    System.out.println("[FAIL] Campos faltantes:");
    fails.forEach(s -> System.out.println("  ✗ " + s));
    globalErrors.addAll(fails);
}
