import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilderFactory;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

import io.cucumber.java.en.When;

public class OperationsFormsBacata {

    @When("^Extraigo datos del ultimo XML en la ruta \"([^\"]+)\" con prefijo \"([^\"]*)\"$")
    public void extraigoDatosDelUltimoXML(String carpetaXML, String prefijo) throws Exception {
        // 1) Carpeta
        Path dir = Paths.get(System.getProperty("user.dir"), carpetaXML);
        if (!Files.isDirectory(dir)) {
            throw new Exception("[XML] Carpeta no válida: " + dir.toAbsolutePath());
        }

        // 2) Elegir el XML más reciente (filtrando por prefijo si viene)
        Path ultimoXml;
        try (var s = Files.list(dir)) {
            ultimoXml = s.filter(p -> p.toString().toLowerCase(Locale.ROOT).endsWith(".xml"))
                         .filter(p -> prefijo == null || prefijo.isBlank()
                                      || p.getFileName().toString().startsWith(prefijo))
                         .max(Comparator.comparingLong(p -> p.toFile().lastModified()))
                         .orElseThrow(() -> new Exception("[XML] No hay XML en " + dir.toAbsolutePath() +
                                                          (prefijo == null ? "" : " con prefijo '" + prefijo + "'")));
        }
        System.out.println("[XML] Archivo más reciente: " + ultimoXml.getFileName() +
                " (mtime=" + Files.getLastModifiedTime(ultimoXml) + ")");

        // 3) Parsear XML
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setNamespaceAware(false);
        dbf.setExpandEntityReferences(false);
        Document doc = dbf.newDocumentBuilder().parse(ultimoXml.toFile());
        doc.getDocumentElement().normalize();

        // 4) Aplanar TODO el árbol
        Map<String, String> flat = new LinkedHashMap<>();
        flattenXml(doc.getDocumentElement(), doc.getDocumentElement().getNodeName(), flat);

        System.out.println("[XML] Total de campos aplanados (full path): " + flat.size());

        // 5) Reducir a claves cortas estilo OPF_variable
        Map<String, String> shortMap = new LinkedHashMap<>();
        for (Map.Entry<String, String> e : flat.entrySet()) {
            String shortKey = toOpfShortKey(e.getKey());
            putUniqueIfDiff(shortMap, shortKey, e.getValue());
        }

        shortMap.forEach((k, v) -> System.out.println("[OPF] " + k + " = " + v));

        // 6) Guardar JSON en archivo
        Path outJson = Paths.get(System.getProperty("user.dir"), "ultimo_xml_OPF.json");
        String json = new org.json.JSONObject(shortMap).toString(2);
        Files.writeString(outJson, json, StandardCharsets.UTF_8);

        System.out.println("[JSON] Guardado en: " + outJson.toAbsolutePath());
    }

    /* ============ Helpers ============ */

    /** Recorre recursivamente el XML y llena 'out' con claves "path.tag" (también atributos "@attr"). */
    private static void flattenXml(Node node, String path, Map<String, String> out) {
        // 1) Atributos
        if (node.hasAttributes()) {
            NamedNodeMap atts = node.getAttributes();
            for (int i = 0; i < atts.getLength(); i++) {
                Node a = atts.item(i);
                String k = path + "@" + a.getNodeName();
                putUniqueIfDiff(out, k, a.getNodeValue());
            }
        }

        // 2) Hijos elemento
        NodeList children = node.getChildNodes();
        List<Element> elemChildren = new ArrayList<>();
        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType() == Node.ELEMENT_NODE) elemChildren.add((Element) n);
        }

        if (elemChildren.isEmpty()) {
            String text = node.getTextContent() == null ? "" : node.getTextContent().trim();
            if (!text.isEmpty()) putUniqueIfDiff(out, path, text);
            return;
        }

        // Recurse
        for (Element e : elemChildren) {
            String tag = e.getNodeName().replaceAll("\\s+", "");
            flattenXml(e, path + "." + tag, out);
        }
    }

    /** Convierte 'root.servicioOtro.fechaDeclaracion' -> 'OPF_fechaDeclaracion'. */
    private static String toOpfShortKey(String fullPath) {
        if (fullPath == null || fullPath.isBlank()) return "OPF_";
        String last = fullPath;
        int idx = fullPath.lastIndexOf('.');
        if (idx >= 0 && idx < fullPath.length() - 1) {
            last = fullPath.substring(idx + 1);
        }
        // Si es atributo 'tag@attr', nos quedamos con el nombre del atributo
        int attrIdx = last.indexOf('@');
        if (attrIdx >= 0 && attrIdx < last.length() - 1) {
            last = last.substring(attrIdx + 1);
        }
        last = last.replaceAll("\\s+", "").replaceAll("[^A-Za-z0-9_]", "_");
        return "OPF_" + last;
    }

    /** Inserta key->value; si existe con valor distinto, agrega [2], [3]… */
    private static void putUniqueIfDiff(Map<String, String> map, String key, String value) {
        if (value == null) value = "";
        value = value.trim();
        if (!map.containsKey(key)) {
            map.put(key, value);
            return;
        }
        if (Objects.equals(map.get(key), value)) {
            return; // ya existe con el mismo valor
        }
        int i = 2;
        while (map.containsKey(key + "[" + i + "]")) {
            if (Objects.equals(map.get(key + "[" + i + "]"), value)) {
                return;
            }
            i++;
        }
        map.put(key + "[" + i + "]", value);
    }
}
