@When("^Agentsit\\s+Actualizo\\s+XML\\s+\"([^\"]+)\"\\s+con\\s+nombre\\s+de\\s+(\\$\\w+)$")
public void actualizoXmlGenerandoNuevo(String rutaXml, String nombreParam) throws Exception {
    System.out.println("==[XML Update]==");
    System.out.println("Plantilla (no se sobreescribe): " + rutaXml);

    // 0) Asegurar plantilla
    Path plantillaPath = java.nio.file.Paths.get(rutaXml);
    if (!java.nio.file.Files.exists(plantillaPath)) {
        Path bak = java.nio.file.Paths.get(rutaXml + ".bak");
        if (java.nio.file.Files.exists(bak)) {
            java.nio.file.Files.copy(bak, plantillaPath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Plantilla restaurada desde .bak");
        } else {
            throw new java.io.FileNotFoundException("No existe la plantilla: " + plantillaPath.toAbsolutePath());
        }
    }

    // 1) Leer TXT
    Path txtPath = java.nio.file.Paths.get("numeros_formularios_masivos.txt");
    java.util.List<String> numeros = java.nio.file.Files.readAllLines(txtPath, java.nio.charset.StandardCharsets.UTF_8);
    numeros.removeIf(s -> s == null || s.trim().isEmpty());
    if (numeros.isEmpty()) {
        throw new IllegalStateException("El TXT está vacío: " + txtPath.toAbsolutePath());
    }

    // 2) Cargar XML
    javax.xml.parsers.DocumentBuilderFactory dbf = javax.xml.parsers.DocumentBuilderFactory.newInstance();
    dbf.setNamespaceAware(true);
    javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();
    org.w3c.dom.Document doc = db.parse(plantillaPath.toFile());
    doc.getDocumentElement().normalize();

    // 3) XPaths
    javax.xml.xpath.XPath xp = javax.xml.xpath.XPathFactory.newInstance().newXPath();
    String XP_NUM  = "//*[local-name()='numeroDeclaracion' or local-name()='referenceNumber']";
    String XP_FECH = "//*[local-name()='fechaDeclaracion' or local-name()='declarationDate']";

    org.w3c.dom.NodeList nn = (org.w3c.dom.NodeList) xp.evaluate(XP_NUM,  doc, javax.xml.xpath.XPathConstants.NODESET);
    org.w3c.dom.NodeList nf = (org.w3c.dom.NodeList) xp.evaluate(XP_FECH, doc, javax.xml.xpath.XPathConstants.NODESET);
    if (nn.getLength() == 0 || nf.getLength() == 0) {
        throw new IllegalStateException("No se encontraron nodos de número o fecha en el XML.");
    }

    // Flexible
    int lenNumNodes   = nn.getLength();
    int lenFechaNodes = nf.getLength();
    int lenNumeros    = numeros.size();
    int n = Math.min(Math.min(lenNumNodes, lenFechaNodes), lenNumeros);
    if (n == 0) {
        throw new IllegalStateException("No hay nada para procesar: nodos numero=" + lenNumNodes +
                                        ", nodos fecha=" + lenFechaNodes + ", numeros TXT=" + lenNumeros);
    }

    String hoy = java.time.LocalDate.now().toString();
    for (int i = 0; i < n; i++) {
        nn.item(i).setTextContent(numeros.get(i));
        nf.item(i).setTextContent(hoy);
    }

    // 4) Resolver nombre desde contexto previo
    String nombreBase = null;
    try {
        Object last = this.getScenarioContext().getLastStepResultVariable();
        if (last != null) {
            if (last.getClass().isArray()) {
                Object first = java.lang.reflect.Array.getLength(last) > 0
                        ? java.lang.reflect.Array.get(last, 0) : null;
                nombreBase = (first != null) ? String.valueOf(first) : null;
            } else {
                nombreBase = String.valueOf(last);
            }
        }
    } catch (Throwable ignore) {}
    if (nombreBase == null || nombreBase.trim().isEmpty()) {
        try {
            String key = (nombreParam != null && nombreParam.startsWith("$")) ? nombreParam.substring(1) : nombreParam;
            Object gcVal = GlobalContext.get(key);               // si no usas GlobalContext, elimina estas 2 líneas
            if (gcVal == null) gcVal = GlobalContext.get(nombreParam);
            nombreBase = (gcVal != null) ? String.valueOf(gcVal) : null;
        } catch (Throwable ignore) {}
    }
    if (nombreBase == null || nombreBase.trim().isEmpty()) {
        throw new IllegalStateException("No pude resolver el nombre capturado. Ejecuta antes 'read text ... into " + nombreParam + "'.");
    }

    // 4.b) Construcción de nombre especial: <baseSinExt>_0001_<ultimaParte>.xml
    String base = nombreBase.trim();
    String baseSinExt = base.replaceFirst("(?i)\\.xml$", "");
    String ultimaParte = baseSinExt.contains("_")
            ? baseSinExt.substring(baseSinExt.lastIndexOf('_') + 1)
            : baseSinExt;

    baseSinExt = java.text.Normalizer.normalize(baseSinExt, java.text.Normalizer.Form.NFD)
            .replaceAll("\\p{M}+", "")
            .replaceAll("[^A-Za-z0-9._-]", "_")
            .replaceFirst("^_+", "");
    ultimaParte = java.text.Normalizer.normalize(ultimaParte, java.text.Normalizer.Form.NFD)
            .replaceAll("\\p{M}+", "")
            .replaceAll("[^A-Za-z0-9._-]", "_")
            .replaceFirst("^_+", "");

    String ext = ".xml";
    java.nio.file.Path dir = (plantillaPath.getParent() == null) ? java.nio.file.Paths.get(".") : plantillaPath.getParent();
    String nombreFinal = baseSinExt + "_0001" + (ultimaParte.isEmpty() ? "" : "_" + ultimaParte) + ext;
    java.nio.file.Path destino = dir.resolve(nombreFinal);

    System.out.println("Archivo final (se sobrescribe si ya existe): " + destino.toAbsolutePath());

    // 5) Guardar nuevo XML
    javax.xml.transform.Transformer tf = javax.xml.transform.TransformerFactory.newInstance().newTransformer();
    tf.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, "yes");
    tf.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
    tf.transform(new javax.xml.transform.dom.DOMSource(doc),
                 new javax.xml.transform.stream.StreamResult(destino.toFile()));

    // Backup de la plantilla (opcional)
    try {
        java.nio.file.Files.copy(plantillaPath, java.nio.file.Paths.get(rutaXml + ".bak"),
                java.nio.file.StandardCopyOption.REPLACE_EXISTING);
    } catch (Exception ignore) {}

    // 6) Copiar ruta completa al portapapeles (para tu diálogo de carga)
    String rutaCompleta = destino.toAbsolutePath().toString();
    java.awt.Toolkit.getDefaultToolkit()
        .getSystemClipboard()
        .setContents(new java.awt.datatransfer.StringSelection(rutaCompleta), null);
    System.out.println("→ Ruta copiada al portapapeles.");

    // 7) Réplica PORTABLE (sin pasar rutas en el feature)
    String envDir  = System.getenv("XML_TARGET_DIR");            // prioridad 1: variable de entorno
    String propDir = System.getProperty("replica.dir");          // prioridad 2: -Dreplica.dir=...
    java.nio.file.Path dirReplica;
    if (envDir != null && !envDir.trim().isEmpty()) {
        dirReplica = java.nio.file.Paths.get(envDir.trim());
        System.out.println("[replica] usando XML_TARGET_DIR=" + dirReplica.toAbsolutePath());
    } else if (propDir != null && !propDir.trim().isEmpty()) {
        dirReplica = java.nio.file.Paths.get(propDir.trim());
        System.out.println("[replica] usando -Dreplica.dir=" + dirReplica.toAbsolutePath());
    } else {
        // prioridad 3 (por defecto): carpeta 'to-upload' junto a la plantilla
        dirReplica = (plantillaPath.getParent() == null)
                ? java.nio.file.Paths.get("to-upload")
                : plantillaPath.getParent().resolve("to-upload");
        System.out.println("[replica] usando carpeta por defecto: " + dirReplica.toAbsolutePath());
    }

    java.nio.file.Files.createDirectories(dirReplica);
    java.nio.file.Path replica = dirReplica.resolve(destino.getFileName());
    java.nio.file.Files.copy(destino, replica, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
    System.out.println("Réplica creada en: " + replica.toAbsolutePath());

    // Fin
    System.out.println("Plantilla intacta: " + plantillaPath.toAbsolutePath());
    System.out.println("Nuevo XML generado: " + rutaCompleta);
    System.out.println("Fecha aplicada: " + hoy + " | Nodos actualizados: " + n);
}
