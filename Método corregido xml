@When("^Consulto datos desde el JSON y la BD con (\\w+)$")
public void cargandoDatosOPF(String agentName, String nombreArchivo, String varName) throws Exception {

    // ================= 0) Config =================
    boolean failAtEnd = Boolean.parseBoolean(System.getProperty("opf.failAtEnd", "true"));
    List<String> globalErrors = new ArrayList<>();

    // ================= 1) Leer archivos base =================
    Path rutaIds = Paths.get(System.getProperty("user.dir"), "identificador_generadoXML.txt");
    if (!Files.exists(rutaIds))
        throw new Exception("[OPF] No existe el archivo de identificador: " + rutaIds.toAbsolutePath());

    Path rutaNums = Paths.get(System.getProperty("user.dir"), "numerosFormularioXML.txt");
    if (!Files.exists(rutaNums))
        throw new Exception("[OPF] No existe el archivo de números de formulario: " + rutaNums.toAbsolutePath());

    List<String> ids = Files.readAllLines(rutaIds, StandardCharsets.UTF_8)
            .stream()
            .filter(s -> s != null && !s.isBlank())
            .map(s -> s.replaceAll("[^0-9]", ""))
            .collect(java.util.stream.Collectors.toList());

    if (ids.isEmpty()) throw new Exception("[OPF] Archivo de IDs vacío.");

    List<String> numerosDec = Files.readAllLines(rutaNums, StandardCharsets.UTF_8)
            .stream()
            .filter(s -> s != null && !s.isBlank())
            .collect(java.util.stream.Collectors.toList());

    // ================= 2) Leer JSON plano =================
    Path rutaJson = Paths.get(System.getProperty("user.dir"), nombreArchivo);
    if (!Files.exists(rutaJson))
        throw new Exception("[OPF] No existe el JSON: " + rutaJson.toAbsolutePath());

    String json = Files.readString(rutaJson, StandardCharsets.UTF_8).trim();
    Map<String, String> kv = JsonUtils.toMap(json);

    System.out.println("[JSON] Campos cargados: " + kv.size());

    // ================= 3) Iterar por bloques =================
    int bloques = Math.max(ids.size(), numerosDec.size());
    if (bloques == 0) throw new Exception("[OPF] No se detectaron bloques en el JSON.");

    for (int i = 0; i < bloques; i++) {
        String sufijo = "[" + (i + 1) + "]";
        String id = ids.get(i);

        // ─── NUEVO: soportar ambos formatos de clave ─────────────────────────────
        // A) OPF.numeroDeclaracion[1]  /  OPF.fechaDeclaracion[1]
        // B) OPF[1].numeroDeclaracion  /  OPF[1].fechaDeclaracion
        String numeroDeclaracion = firstNonNull(
                kv.get("OPF.numeroDeclaracion" + sufijo),
                kv.get("OPF" + sufijo + ".numeroDeclaracion")
        );
        String fechaDeclaracion = firstNonNull(
                kv.get("OPF.fechaDeclaracion" + sufijo),
                kv.get("OPF" + sufijo + ".fechaDeclaracion")
        );
        // ─────────────────────────────────────────────────────────────────────────

        // Validar datos mínimos
        if (numeroDeclaracion == null || fechaDeclaracion == null
                || numeroDeclaracion.isBlank() || fechaDeclaracion.isBlank()) {
            String msg = "[OPF] Faltan datos mínimos para bloque " + sufijo
                    + " en JSON: " + numeroDeclaracion + " / " + fechaDeclaracion;
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }

        // ================= 3.2 Determinar tabla según ID =================
        String tabla, idCol1, dateCol1;
        switch (id) {
            case "1":
                tabla = "BAC_FMV1_FOR_INV_INTERNAS";
                idCol1 = "D19S_NUM_DEC_JIINC";
                dateCol1 = "D19S_FECHA_DEC_JIINC";
                break;
            case "2":
                tabla = "BAC_FMV1_FOR_INV_EXTERNA";
                idCol1 = "D19E_NUM_DEC_JIINC";
                dateCol1 = "D19E_FECHA_DEC_JIINC";
                break;
            case "3":
                tabla = "BAC_FMV1_FOR_DEUDA_EXTER";
                idCol1 = "DEE_NUM_DEC_JIINC";
                dateCol1 = "DEE_FECHA_DEC_JIINC";
                break;
            case "4":
                tabla = "BAC_FMV1_FOR_IMPORT_BIENES";
                idCol1 = "DIMP_NUM_DEC_JIINC";
                dateCol1 = "DIMP_FECHA_DEC_JIINC";
                break;
            case "5":
                tabla = "BAC_FMV1_FOR_SERV_TRANSF_OTROS";
                idCol1 = "DST_NUM_DEC_JIINC";
                dateCol1 = "DST_FECHA_DEC_JIINC";
                break;
            default:
                throw new IllegalArgumentException("Identificador de formulario desconocido: " + id);
        }

        String fechaFormateada = DateUtils.toOracleDayMonthYear(fechaDeclaracion);

        // ================= 3.3 SQL =================
        String sql = String.format(
                "SELECT JSON_OBJECT(*) AS ROW_JSON FROM %s WHERE %s LIKE '%%%s%%' AND %s = '%s' FETCH FIRST 1 ROWS ONLY",
                tabla, idCol1, numeroDeclaracion, dateCol1, fechaFormateada);

        System.out.println("[BD] Consulta generada: " + sql);

        // ================= 3.4 Ejecutar consulta =================
        StepResult db;
        try {
            Agent dbAgent = AgentsManager.getInstance().getOrCreateAgent(agentName);
            db = dbAgent.runMethod("query", new Object[]{sql});
        } catch (Exception ex) {
            String msg = "[BD] Error ejecutando query bloque " + sufijo + ": " + ex.getMessage();
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }

        if (db == null) {
            String msg = "[BD] Resultado nulo bloque " + sufijo;
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }

        // ================= 3.5 Bloque de JSON =================
        String rowJson = String.valueOf(db.getFieldValue("ROW_JSON"));
        if (rowJson == null || rowJson.isBlank() || "null".equalsIgnoreCase(rowJson)) {
            String msg = "[BD] Respuesta vacía bloque " + sufijo;
            System.out.println(msg);
            globalErrors.add(msg);
            continue;
        }

        getScenarioContext().saveLastStepResult(db, varName);

        // ================= 3.6 Armar bloque de claves/valores del JSON =================
        Map<String, String> kvBlock = new LinkedHashMap<>();
        for (Map.Entry<String, String> e : kv.entrySet()) {
            String k = e.getKey();
            String v = e.getValue();
            if (v == null || v.trim().isEmpty()) continue;

            boolean belongs = false;
            String baseKey = null;

            // Formato A: OPF.campo[1]
            if (k.startsWith("OPF.") && k.endsWith(sufijo)) {
                baseKey = k.substring(0, k.length() - sufijo.length()); // OPF.campo
                belongs = true;
            }
            // Formato B: OPF[1].campo
            else if (k.startsWith("OPF" + sufijo + ".")) {
                baseKey = "OPF." + k.substring(("OPF" + sufijo + ".").length()); // OPF.campo
                belongs = true;
            }

            if (belongs) {
                // guardamos usando baseKey+sufijo (solo para mantener consistencia en logs)
                kvBlock.put(baseKey + sufijo, v);
            }
        }

        // ================= 3.7 Validación =================
        Map<String, String> overrides = new HashMap<>();
        overrides.put("OPF.fechaDeclaracion", DateUtils.toOracleDayMonthYear(fechaDeclaracion));

        List<String> oks = new ArrayList<>();
        List<String> fails = new ArrayList<>();

        String jsonDb = rowJson.replaceAll("\\s+", "");

        for (Map.Entry<String, String> e : kvBlock.entrySet()) {
            String keyWithSuffix = e.getKey();          // OPF.campo[1]
            String value = e.getValue();

            // BaseKey solo para imprimir bonito: OPF.campo
            String baseKey = keyWithSuffix.substring(0, keyWithSuffix.length() - sufijo.length());

            // Comparación flexible (case-insensitive, sin espacios ni tildes)
            boolean found = containsJsonValue(jsonDb, value);
            if (found) {
                oks.add(baseKey);
            } else {
                fails.add(baseKey + " -> '" + value + "'");
            }
        }

        System.out.println(String.format("[RESUMEN] Bloque %s → OK:%d  FAIL:%d", sufijo, oks.size(), fails.size()));

        if (!oks.isEmpty()) {
            System.out.println("[OK] Campos encontrados:");
            oks.forEach(s -> System.out.println(" - " + s));
        }
        if (!fails.isEmpty()) {
            System.out.println("[FAIL] Campos faltantes (valor esperado):");
            fails.forEach(s -> System.out.println(" - " + s));
            globalErrors.addAll(fails);
        }
    }

    // ================= 4) Resumen final =================
    if (globalErrors.isEmpty()) {
        System.out.println("\n===== RESUMEN FINAL: TODO OK =====");
    } else {
        System.out.println("\n===== RESUMEN FINAL: HAY FALTANTES =====");
        globalErrors.forEach(s -> System.out.println(" - " + s));
        if (failAtEnd)
            throw new AssertionError("Existen " + globalErrors.size() + " validaciones fallidas. Revisa el log.");
    }
}

/* ───────────────────── Helpers nuevos/ya usados ───────────────────── */

private static <T> T firstNonNull(T a, T b) { return (a != null) ? a : b; }

// Normalización y comparación flexible
private static boolean containsJsonValue(String haystackRaw, String expectedRaw) {
    if (haystackRaw == null || expectedRaw == null) return false;

    String haystack = normalizeString(haystackRaw);
    String needle   = normalizeString(expectedRaw);

    if (needle.isEmpty()) return false;
    if (haystack.contains(needle)) return true;

    // quitar separadores comunes para números/montos
    String needleNoSep = needle.replaceAll("[,._\\s]", "");
    String hayNoSep    = haystack.replaceAll("[,._\\s]", "");
    if (!needleNoSep.isEmpty() && hayNoSep.contains(needleNoSep)) return true;

    // interpretar fecha yyyy-MM-dd como dd-MMM-yy en inglés (p.ej. 2025-09-16 -> 16-SEP-25)
    try {
        java.time.LocalDate d = java.time.LocalDate.parse(expectedRaw.trim());
        String oracle = d.format(java.time.format.DateTimeFormatter.ofPattern("dd-MMM-yy", java.util.Locale.ENGLISH))
                         .toUpperCase(java.util.Locale.ENGLISH);
        String oracleNorm = normalizeString(oracle);
        if (haystack.contains(oracleNorm) || hayNoSep.contains(oracleNorm.replaceAll("\\s+",""))) return true;
    } catch (Exception ignore) {}

    return false;
}

private static String normalizeString(String s) {
    if (s == null) return "";
    String u = s.toUpperCase(java.util.Locale.ROOT);
    u = java.text.Normalizer.normalize(u, java.text.Normalizer.Form.NFD).replaceAll("\\p{M}", "");
    u = u.replaceAll("\\s+", "");
    return u.trim();
}

static class DateUtils {
    private static final java.time.format.DateTimeFormatter IN =
            java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final java.time.format.DateTimeFormatter OUT =
            java.time.format.DateTimeFormatter.ofPattern("dd-MMM-yy", java.util.Locale.ENGLISH);

    static String toOracleDayMonthYear(String yyyyMMdd) {
        return java.time.LocalDate.parse(yyyyMMdd, IN).format(OUT).toUpperCase(java.util.Locale.ENGLISH);
    }
}
